{"version":3,"file":"DevicePushTokenAutoRegistration.fx.js","sourceRoot":"","sources":["../src/DevicePushTokenAutoRegistration.fx.ts"],"names":[],"mappings":"AAAA,OAAO,wBAAwB,MAAM,4BAA4B,CAAC;AAClE,OAAO,EAAE,oBAAoB,EAAE,MAAM,gBAAgB,CAAC;AAEtD,OAAO,EACL,oBAAoB,EACpB,uBAAuB,EACvB,yBAAyB,GAC1B,MAAM,8BAA8B,CAAC;AAWtC;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,8BAA8B,CAClD,YAAyE;IAEzE,uDAAuD;IACvD,gCAAgC;IAChC,yBAAyB,EAAE,CAAC;IAC5B,kEAAkE;IAClE,MAAM,wBAAwB,CAAC,wBAAwB,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC;AAC1F,CAAC;AAED;;;GAGG;AACH,MAAM,CAAC,KAAK,UAAU,iCAAiC;IACrD,oDAAoD;IACpD,gCAAgC;IAChC,yBAAyB,EAAE,CAAC;IAC5B,uDAAuD;IACvD,MAAM,wBAAwB,CAAC,wBAAwB,EAAE,CAAC,IAAI,CAAC,CAAC;AAClE,CAAC;AAED;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,sCAAsC,CAC1D,gBAA2C;IAE3C,IAAI,CAAC,gBAAgB,EAAE;QACrB,sCAAsC;QACtC,OAAO;KACR;IACD,IAAI;QACF,MAAM,YAAY,GAAgC,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;QAC/E,+DAA+D;QAC/D,uEAAuE;QACvE,gEAAgE;QAChE,sDAAsD;QACtD,IAAI,YAAY,EAAE,sBAAsB,IAAI,CAAC,uBAAuB,EAAE,EAAE;YACtE,oBAAoB,CAAC,YAAY,CAAC,sBAAsB,CAAC,CAAC;SAC3D;KACF;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,CAAC,IAAI,CACV,wGAAwG,EACxG,CAAC,CACF,CAAC;KACH;AACH,CAAC;AAED,mCAAmC;AACnC,uCAAuC;AACvC,oCAAoC;AACpC,wBAAwB,CAAC,wBAAwB,EAAE,EAAE,CAAC,IAAI,CAAC,sCAAsC,CAAC,CAAC;AAEnG,4DAA4D;AAC5D,+BAA+B;AAC/B,oBAAoB,CAAC,KAAK,CAAC,EAAE;IAC3B,uCAAuC;IACvC,+BAA+B;IAC/B,oBAAoB,CAAC,KAAK,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC","sourcesContent":["import ServerRegistrationModule from './ServerRegistrationModule';\nimport { addPushTokenListener } from './TokenEmitter';\nimport { DevicePushToken } from './Tokens.types';\nimport {\n  updatePushTokenAsync,\n  hasPushTokenBeenUpdated,\n  interruptPushTokenUpdates,\n} from './utils/updatePushTokenAsync';\n\n/**\n * Encapsulates device server registration data\n */\nexport type DevicePushTokenRegistration = {\n  url: string;\n  body: Record<string, any>;\n  pendingDevicePushToken?: DevicePushToken | null;\n};\n\n/**\n * Sets the registration information so that the device push token gets pushed\n * to the given registration endpoint\n * @param registration Registration endpoint to inform of new tokens\n */\nexport async function setAutoServerRegistrationAsync(\n  registration: Omit<DevicePushTokenRegistration, 'pendingDevicePushToken'>\n) {\n  // We are overwriting registration, so we shouldn't let\n  // any pending request complete.\n  interruptPushTokenUpdates();\n  // Remember the registration information for future token updates.\n  await ServerRegistrationModule.setRegistrationInfoAsync?.(JSON.stringify(registration));\n}\n\n/**\n * Removes last Expo server registration, future device push token\n * updates won't get sent there anymore.\n */\nexport async function removeAutoServerRegistrationAsync() {\n  // We are removing registration, so we shouldn't let\n  // any pending request complete.\n  interruptPushTokenUpdates();\n  // Do not consider any registration when token updates.\n  await ServerRegistrationModule.setRegistrationInfoAsync?.(null);\n}\n\n/**\n * This function is exported only for testing purposes.\n */\nexport async function __handlePersistedRegistrationInfoAsync(\n  registrationInfo: string | null | undefined\n) {\n  if (!registrationInfo) {\n    // No registration info, nothing to do\n    return;\n  }\n  try {\n    const registration: DevicePushTokenRegistration = JSON.parse(registrationInfo);\n    // We only want to retry if `hasPushTokenBeenUpdated` is false.\n    // If it were true it means that another call to `updatePushTokenAsync`\n    // has already occured which could only happen from the listener\n    // which has newer information than persisted storage.\n    if (registration?.pendingDevicePushToken && !hasPushTokenBeenUpdated()) {\n      updatePushTokenAsync(registration.pendingDevicePushToken);\n    }\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while fetching registration information for auto token updates.',\n      e\n    );\n  }\n}\n\n// Verify if persisted registration\n// has successfully uploaded last known\n// device push token. If not, retry.\nServerRegistrationModule.getRegistrationInfoAsync?.().then(__handlePersistedRegistrationInfoAsync);\n\n// A global scope (to get all the updates) device push token\n// subscription, never cleared.\naddPushTokenListener(token => {\n  // Dispatch an abortable task to update\n  // registration with new token.\n  updatePushTokenAsync(token);\n});\n"]}