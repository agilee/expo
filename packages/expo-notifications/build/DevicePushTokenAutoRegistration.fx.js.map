{"version":3,"file":"DevicePushTokenAutoRegistration.fx.js","sourceRoot":"","sources":["../src/DevicePushTokenAutoRegistration.fx.ts"],"names":[],"mappings":"AAAA,OAAO,wBAAwB,MAAM,4BAA4B,CAAC;AAClE,OAAO,EAAE,oBAAoB,EAAE,MAAM,gBAAgB,CAAC;AACtD,OAAO,uBAAuB,MAAM,2BAA2B,CAAC;AAChE,OAAO,EAAE,oBAAoB,EAAE,yBAAyB,EAAE,MAAM,8BAA8B,CAAC;AAS/F;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,qCAAqC,CAAC,OAAgB;IAC1E,uDAAuD;IACvD,gCAAgC;IAChC,yBAAyB,EAAE,CAAC;IAE5B,MAAM,wBAAwB,CAAC,wBAAwB,EAAE,CACvD,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CACxD,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,sCAAsC,CAC1D,gBAA2C;IAE3C,IAAI,CAAC,gBAAgB,EAAE;QACrB,sCAAsC;QACtC,OAAO;KACR;IAED,IAAI,YAAY,GAAuC,IAAI,CAAC;IAC5D,IAAI;QACF,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;KAC7C;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,CAAC,IAAI,CACV,wGAAwG,EACxG,CAAC,CACF,CAAC;KACH;IAED,IAAI,CAAC,YAAY,EAAE,SAAS,EAAE;QAC5B,6DAA6D;QAC7D,OAAO;KACR;IAED,IAAI;QACF,mEAAmE;QACnE,0BAA0B;QAC1B,MAAM,qBAAqB,GAAG,MAAM,uBAAuB,EAAE,CAAC;QAC9D,MAAM,oBAAoB,CAAC,qBAAqB,CAAC,CAAC;KACnD;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,CAAC,IAAI,CACV,0GAA0G,EAC1G,CAAC,CACF,CAAC;KACH;AACH,CAAC;AAED,mCAAmC;AACnC,uCAAuC;AACvC,oCAAoC;AACpC,wBAAwB,CAAC,wBAAwB,EAAE,EAAE,CAAC,IAAI,CAAC,sCAAsC,CAAC,CAAC;AAEnG,4DAA4D;AAC5D,+BAA+B;AAC/B,oBAAoB,CAAC,KAAK,CAAC,EAAE;IAC3B,uCAAuC;IACvC,+BAA+B;IAC/B,oBAAoB,CAAC,KAAK,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC","sourcesContent":["import ServerRegistrationModule from './ServerRegistrationModule';\nimport { addPushTokenListener } from './TokenEmitter';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\nimport { updatePushTokenAsync, interruptPushTokenUpdates } from './utils/updatePushTokenAsync';\n\n/**\n * Encapsulates device server registration data\n */\nexport type DevicePushTokenRegistration = {\n  isEnabled: boolean;\n};\n\n/**\n * Sets the registration information so that the device push token gets pushed\n * to the given registration endpoint\n * @param registration Registration endpoint to inform of new tokens\n */\nexport async function setAutoServerRegistrationEnabledAsync(enabled: boolean) {\n  // We are overwriting registration, so we shouldn't let\n  // any pending request complete.\n  interruptPushTokenUpdates();\n\n  await ServerRegistrationModule.setRegistrationInfoAsync?.(\n    enabled ? JSON.stringify({ isEnabled: enabled }) : null\n  );\n}\n\n/**\n * This function is exported only for testing purposes.\n */\nexport async function __handlePersistedRegistrationInfoAsync(\n  registrationInfo: string | null | undefined\n) {\n  if (!registrationInfo) {\n    // No registration info, nothing to do\n    return;\n  }\n\n  let registration: DevicePushTokenRegistration | null = null;\n  try {\n    registration = JSON.parse(registrationInfo);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while fetching registration information for auto token updates.',\n      e\n    );\n  }\n\n  if (!registration?.isEnabled) {\n    // Registration is invalid or not enabled, nothing more to do\n    return;\n  }\n\n  try {\n    // Since the registration is enabled, fetching a \"new\" device token\n    // shouldn't be a problem.\n    const latestDevicePushToken = await getDevicePushTokenAsync();\n    await updatePushTokenAsync(latestDevicePushToken);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n      e\n    );\n  }\n}\n\n// Verify if persisted registration\n// has successfully uploaded last known\n// device push token. If not, retry.\nServerRegistrationModule.getRegistrationInfoAsync?.().then(__handlePersistedRegistrationInfoAsync);\n\n// A global scope (to get all the updates) device push token\n// subscription, never cleared.\naddPushTokenListener(token => {\n  // Dispatch an abortable task to update\n  // registration with new token.\n  updatePushTokenAsync(token);\n});\n"]}