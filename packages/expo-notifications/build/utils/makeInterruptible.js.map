{"version":3,"file":"makeInterruptible.js","sourceRoot":"","sources":["../../src/utils/makeInterruptible.ts"],"names":[],"mappings":"AAAA,OAAO,eAAe,MAAM,kBAAkB,CAAC;AAE/C;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,MAAM,CAAC,OAAO,UAAU,iBAAiB,CACvC,IAAiE;IAEjE,IAAI,qBAAqB,GAA2B,IAAI,CAAC;IACzD,IAAI,aAAa,GAAG,KAAK,CAAC;IAE1B,SAAS,wBAAwB;QAC/B,OAAO,aAAa,CAAC;IACvB,CAAC;IAED,SAAS,SAAS;QAChB,qBAAqB,EAAE,KAAK,EAAE,CAAC;QAC/B,qBAAqB,GAAG,IAAI,CAAC;IAC/B,CAAC;IAED,KAAK,UAAU,QAAQ,CAAC,GAAG,IAAe;QACxC,aAAa,GAAG,IAAI,CAAC;QACrB,+BAA+B;QAC/B,SAAS,EAAE,CAAC;QACZ,qBAAqB,GAAG,IAAI,eAAe,EAAE,CAAC;QAC9C,MAAM,oBAAoB,GAAG,qBAAqB,CAAC;QAEnD,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;QAC/B,IAAI,WAAgB,CAAC;QACrB,OAAO,IAAI,EAAE;YACX,6BAA6B;YAC7B,IAAI,oBAAoB,CAAC,MAAM,CAAC,OAAO,EAAE;gBACvC,OAAO,CAAC,sBAAsB;aAC/B;YACD,mEAAmE;YACnE,uFAAuF;YACvF,MAAM,OAAO,GAAG,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAC3C,IAAI,OAAO,CAAC,IAAI,EAAE;gBAChB,OAAO,OAAO,CAAC,KAAK,CAAC,CAAC,yCAAyC;aAChE;YAED,qBAAqB;YACrB,IAAI,oBAAoB,CAAC,MAAM,CAAC,OAAO,EAAE;gBACvC,OAAO,CAAC,sBAAsB;aAC/B;YACD,wDAAwD;YACxD,WAAW,GAAG,MAAM,OAAO,CAAC,KAAK,CAAC;YAClC,0DAA0D;SAC3D;IACH,CAAC;IAED,OAAO,CAAC,QAAQ,EAAE,wBAAwB,EAAE,SAAS,CAAC,CAAC;AACzD,CAAC","sourcesContent":["import AbortController from 'abort-controller';\n\n/**\n * Takes in a generator function and creates a regular function\n * that calls (goes through all the values generated by)\n * the generator function, but it:\n * 1. makes it interruptible on the generator function's `yield`s\n *    (interrupting = stopping generating new values from the generator)\n * 2. makes it automatically interrupted by another call.\n *\n * It always calls the iterator for the next value passing in\n * awaited result of a previous yielded value which makes\n * it easy to create interruptible asynchronous methods.\n *\n * For more information see https://dev.to/chromiumdev/cancellable-async-functions-in-javascript-5gp7\n *\n * @param func The generator function\n * @return An array of three elements:\n * 1. An async function that triggers \"calling\" the generator passed in.\n *    It resolves with the final value returned by the generator\n *    or undefined if the call has been interrupted by another call.\n * 2. A function returning whether any call has already been made\n *    to the generator.\n * 3. A function interrupting processing of the generator.\n */\nexport default function makeInterruptible<Arguments extends any[] = any[], Result = void>(\n  func: (...args: Arguments) => Generator<unknown, Result, unknown>\n): [(...args: Arguments) => Promise<Result | undefined>, () => boolean, () => void] {\n  let globalAbortController: null | AbortController = null;\n  let hasBeenCalled = false;\n\n  function hasBeenCalledAtLeastOnce() {\n    return hasBeenCalled;\n  }\n\n  function interrupt() {\n    globalAbortController?.abort();\n    globalAbortController = null;\n  }\n\n  async function callFunc(...args: Arguments) {\n    hasBeenCalled = true;\n    // Interrupt any existing calls\n    interrupt();\n    globalAbortController = new AbortController();\n    const localAbortController = globalAbortController;\n\n    const iterator = func(...args);\n    let resumeValue: any;\n    while (true) {\n      // Guard before .next() await\n      if (localAbortController.signal.aborted) {\n        return; // a new call was made\n      }\n      // We can use a mix of function generator and asynchronous function\n      // as per https://www.pluralsight.com/guides/using-asyncawait-with-generator-functions.\n      const element = iterator.next(resumeValue);\n      if (element.done) {\n        return element.value; // final return value of passed generator\n      }\n\n      // Guard before await\n      if (localAbortController.signal.aborted) {\n        return; // a new call was made\n      }\n      // whatever the generator yielded, _now_ run await on it\n      resumeValue = await element.value;\n      // next loop, we'll give resumeValue back to the generator\n    }\n  }\n\n  return [callFunc, hasBeenCalledAtLeastOnce, interrupt];\n}\n"]}