{"version":3,"file":"updatePushTokenAsync.js","sourceRoot":"","sources":["../../src/utils/updatePushTokenAsync.ts"],"names":[],"mappings":"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","sourcesContent":["import { computeNextBackoffInterval } from '@ide/backoff';\nimport { CodedError, Platform, UnavailabilityError } from '@unimodules/core';\nimport { AbortSignal } from 'abort-controller';\nimport * as Application from 'expo-application';\n\nimport ServerRegistrationModule from '../ServerRegistrationModule';\nimport { DevicePushToken } from '../Tokens.types';\n\nconst updatePushTokenUrl = 'https://exp.host/--/api/v2/push/updateDeviceToken';\n\nexport async function updatePushTokenAsync(signal: AbortSignal, token: DevicePushToken) {\n  const doUpdatePushTokenAsync = async (retry: () => void) => {\n    try {\n      const body = {\n        development: await shouldUseDevelopmentNotificationService(),\n        deviceToken: token.data,\n        appId: Application.applicationId,\n        deviceId: await getDeviceIdAsync(),\n        type: getTypeOfToken(token),\n      };\n\n      const response = await fetch(updatePushTokenUrl, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n        },\n        body: JSON.stringify(body),\n        signal,\n      }).catch(error => {\n        // Error returned if the request is aborted should have 'AbortError'. In\n        // React Native fetch is polyfilled using `whatwg-fetch` which:\n        // - creates `AbortError`s like this\n        //   https://github.com/github/fetch/blob/75d9455d380f365701151f3ac85c5bda4bbbde76/fetch.js#L505\n        // - which creates exceptions like\n        //   https://github.com/github/fetch/blob/75d9455d380f365701151f3ac85c5bda4bbbde76/fetch.js#L490-L494\n        if (error.name === 'AbortError') {\n          throw error;\n        } else {\n          throw new CodedError(\n            'ERR_NOTIFICATIONS_NETWORK_ERROR',\n            `Error encountered while updating device push token in server: ${error}.`\n          );\n        }\n      });\n\n      // Help debug erroring servers\n      if (!response.ok) {\n        console.debug(\n          '[expo-notifications] Error encountered while updating device push token in server:',\n          await response.text()\n        );\n      }\n\n      // Retry if request failed\n      if (!response.ok) {\n        retry();\n      }\n    } catch (e) {\n      console.warn(\n        '[expo-notifications] Error thrown while updating device push token in server:',\n        e\n      );\n\n      // We only want to retry if it was a network error.\n      // Other error may be JSON.parse error which we can do nothing about.\n      if (e instanceof CodedError && (e as CodedError).code === 'ERR_NOTIFICATIONS_NETWORK_ERROR') {\n        retry();\n      } else {\n        // If we aren't going to try again, throw the error\n        throw e;\n      }\n    }\n  };\n\n  let shouldTry = true;\n  const retry = () => {\n    shouldTry = true;\n  };\n\n  let retriesCount = 0;\n  const initialBackoff = 500; // 0.5 s\n  const backoffOptions = {\n    maxBackoff: 2 * 60 * 1000, // 2 minutes\n  };\n  let nextBackoffInterval = computeNextBackoffInterval(\n    initialBackoff,\n    retriesCount,\n    backoffOptions\n  );\n\n  while (shouldTry && !signal.aborted) {\n    // Will be set to true by `retry` if it's called\n    shouldTry = false;\n    await doUpdatePushTokenAsync(retry);\n\n    // Do not wait if we won't retry\n    if (shouldTry && !signal.aborted) {\n      nextBackoffInterval = computeNextBackoffInterval(\n        initialBackoff,\n        retriesCount,\n        backoffOptions\n      );\n      retriesCount += 1;\n      await new Promise(resolve => setTimeout(resolve, nextBackoffInterval));\n    }\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_DEVICE_ID',\n      `Could not have fetched installation ID of the application: ${e}.`\n    );\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment = await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch (e) {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n"]}